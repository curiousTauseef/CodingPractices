Reference Books:
(1) Cracking the coding interview
(2) Head first Java
(3) Leetcode

1. Arrays and HashTables

Knowledge:
(1) Hash Tables -- implementation, performance, collision.
(2) Resizeable array
	Implementation: Vector(C++), ArrayList(Java)
	Performance: get, set is O(1), amortized time of add is O(1) and why. 
(3) Basic language syntax for array(fixed and dynamic), hash map and hash set.
(4) Implementation of equals and hashCode methods in Java(See <<Effective Java>>,
http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html)

Problems:
(1)[Leetcode]First Missing Positive(Algorithm and Implementation*)
(2) K Sum problems. Can be solved using two approaches:
    a. Sort the input array first. Then using two pointers starting from the beginning
    and the end of the array, moving one of them towards the other each time based
    on the comparison of the sum of the two elements and target, until they meet.
    The two pointers process takes O(n) time. No extra space needed.
    b. Using a hash set of list of n elements to record the results and remove duplicates.
    Sort the input array first if K > 2. Cache the sums and their corresponding elements
    while iterating the array. The result hash set has to be used to remove the duplicates!

    No matter which approach to use, divide K into two parts first. Iterate the second part
    and hash or iterate using two pointers on the first part.

    (2.1) Two sum
        (2.1.1) Input array is random, find out one solution.
            - [Leetcode] Two sum.
        (2.1.2) Input array is random, find out all unique solutions.
    (2.2) Three sum
        (2.1.1) Input array is random, find out all unique solutions.
            - [Leetcode] Three sum.
            - [Leetcode] Three sum closest.
    (2.3) Four sum(Random input array, find out all unique solutions)
        -[Leetcode] Four sum.
(3) Remove duplicates(Maximum allowed duplicates == K). Two ways of checking duplicates!
    - [Leetcode] Remove Duplicates from Sorted Array(Best Algorithm*).
    - [Leetcode] Remove Duplicates from Sorted Array2(Best Algorithm*).
(4) Inward two pointers:
    - [Leetcode] Previous three sum problems.
    - [Leetcode] Container with most water(Algorithm)
    - [Leetcode] Trapping rain water(Multiple Algorithms* and implementation*)


2. Strings

Knowledge:
(1)JAVA: String, StringBuilder and char[]

Problems:
(1)[Leetcode]Integer To Roman(Algorithm*)
(2)[Leetcode]Roman To Integer(Algorithm*)
(3)Sliding window approach for substring problems:
    * Think about why sliding window approach would work first. It basically considers
    each substring that starts with the character at the left pointer and skip some
    by moving the left pointer. The substring within the sliding window(before the
    right pointer) often satisfies a certain condition. And usually the substrings
    starting from the characters in between don't satisfy that condition.
    * A map of character to position or character to count should be created at the
    beginning. Sometimes one may not be enough. Especially when there are multiple
    input strings.
    * The main for loop is moving the right pointer and check each character to see
    if it should stop and begin moving the left pointer. Need to think very carefully
    about this check. When the check doesn't pass, usually we need to update the map,
    in some ways. (Sometimes the map should always be updated)
    * If the above check passes, then an inner loop should be performed to move the
    left pointer. Remember to update the result(max/min length) first. Depending on
    the specific problem, the left pointer can or cannot be moved to the destination
    directly. Also during this process we might need to remove or change some entries
    in the map.
    * Return the max/min result. May need to do one more comparision.

    - [Leetcode]Longest Substring Without Repeating Characters(Best Algorithm* and
    Implementation),
    - [Leetcode]Longest Substring with At Most K Distinct Characters(Algorithm* and
    Implementation*)
    - [Leetcode]Minimum Window Substring(Algorithm* and Implementation*)
    - [Leetcode]Substring with Concatenation of All Words(Algorithm* and Implementation*)


3. Linked Lists

Knowledge:
(1)Java: LinkedList class -- double linked list, performance
(2)Two pointers technique is frequently used! The diff between any two given linked
list can always be found in O(m+n) time.
(3)Sometimes we can use the input pointers to reduce the number of pointers created.
(4)It is possible to delete a node only by using that pointer if that node is not
the head or tail --- by shifting the contents of the following nodes toward it and
remove the last one.
(5)Adding dummy node to the front a linked list can be convenient for iterating over
the list using two pointers, especially if we want to remove the first node, or insert
in front of the first node. Think carefully about edge cases involving the head node
if we do not want to add the dummy node(for node finding problems, think about the
case when there is only one node in a list).
(6)Edge cases: (think normal case first), insert/remove the first/last node, one node
linked list, null list.
(7)Three approaches for reversing linked list and their implementation(see below).

Problems:
(1)Node finding:
    - [Leetcode]Intersection Of Two Linked Lists(Best Algorithm* and Best Implementation*)
 Remember this algorithm(including the first trial)!
    - [Leetcode]Linked List Cycle II(Algorithm* and Implementation*)
(2)Remove nodes: 
    - [Leetcode]Remove Nth Node From End of List(Implementation, practice dummy node,
    two pointers moving and edge case thinking)
    - [Leetcode]Remove duplicates from sorted list I(easy) and II(Implementation*)
    - Generalization of above to allow K duplicates -- Remove duplicates from sorted
    list III.(Implementation* -- multiple cases)
(3)Reverse nodes: 
	(3.1). Basic head insertion(Iterative and recursive) -- creating a new linked list,
    original head pointer will become tail pointer, and the new head pointer keeps
    updating. No need for the dummy node.
	   - [Leetcode] Reverse Linked List(Implementation, recursive algorithm*)
	(3.2). Incremental head insertion -- This process includes node removing and node
    insertion. Must add dummy node. Must start from the second node(cur node start
    from curTail.next) and use a pointer pointing to the tail node(curTail is fixed!)
    that other nodes are inserted before.
	   - [Leetcode]Swap Nodes in Pairs(Implementation)
	   - [Leetcode]Reverse Nodes in K-Group(Algorithm* and Implementation*)
	   - [Leetcode]Reverse Linked List II(Implementation*)
	(3.3). Tail insertion. Inserting each node right after the original tail node. Need
    to first aquire pointer to the tail node and then start from the first node. Original
    tail node will become new head node. Pointer to the original head node need to
    be stored or it will be lost.
    - [Leetcode]Reverse Nodes in K-Group(Algorithm* and Implementation*)
(4)Re-arrange nodes:
    Removing nodes first, and then either insert them into the original list or a
    new list. The latter way requires creating a new dummy node and tail node for
    appending, more nodes than the former way but could be simpler. The former way
    need to deal with some special cases, like removing and inserting into the old
    place, which could affect the next position of the pointer.
    - [Leetcode]Rotate List(Implementation, practice two pointers moving--two ways)
    - [Leetcode]Partition List(Best algorithm*)
(4)Copy linked list:
	- [Leetcode]Copy List with Random Pointer(Algorithm*, two approaches)


4. Stack and Queue

Knowledge:
(1)stack can be implemented as resizable array or linked list; queue can be implemented
as cyclic array, double resizeable array or linked list.
(2)Java implemenation: 
Interfact Deque<E>, push(E item), pop(), peek(). 
Interface Queue<E>, offer(e), poll(), peek(). 
Iteration using iterator and descendingItarator -- different results!
Both of them can be implemented as class ArrayDeque<E>, which is very likely a double
direction resizeable array. According to java doc, "This class is likely to be faster
than Stack when used as a stack, and faster than LinkedList when used as a queue".
This data structure doesn't allow null element, as peek() returns null when the deque
is empty. peek() does not throw any exceptions.
(3)In some design problems, sometimes it is good to call peek() first in pop()/poll
().

Problems:
(1)[Leetcode]Simplify path(Implementation*)
(2)[Leetcode]Evaluate reverse polish notation(Implementation)
(3)[Leetcode]Min stack(Multiple algorithms*, practice conversion between primitive
types and Binary Numeric Promotion)
(4)[Leetcode]Implement queue using stacks(Algorithm*)
(5)[Leetcode]Implement stack using queues(Best Algorithm*)


5. Trees

Knowledge:
(1)Definition of tree, binary tree and binary search tree, and the differences between
them. For BST, definition can vary slightly with respect to equality, if there could
be duplicate values.
(2)Balanced vs Unbalanced. Two common types of balanced trees are red-black tree and
AVL tree.
(3)Definition of complete, full and perfect binary trees.
(4)Binary tree number of nodes n = 2^k - 1 (k is the number of levels)
(5)Binary tree inorder, preorder and postorder traversal and their three implementations
(see related problems below). -- N-ary trees?
(6)About Morris traversal: the basic idea is to use null right child of some nodes
to store the succedents beforehand and delete them afterhand. Preorder and inorder
are similar, since the right children are always traversed at last, and therefore
after traversing back through the thread pointer there is no need to visit the left
children again. However for postorder traversal, the parent node is traversed at last.
So after traversing back through the thread pointer, the left children have to be
visited reversely(only those nodes from the diret left child all the way down to the
right). It is also necessary to create a dummy node and have its left child be the
root.

Problems:
(1)Binary tree inorder traversal(Algorithms* and Implementation*)
(2)Binary tree preorder traversal(Algorithms* and implementation)
(3)Binary tree postorder traversal(Algorithms* and implementation), it can be seen
as a reverse of preorder traversal.

Implementation Utils:
1. Sorting an array:
    (1) Java:
            int[] nums;
            Arrays.sort(nums);//In place, stable, O(nlogn) time.

2. Max and min Int
    (1) Java:
            Integer.MAX_VALUE;
            Integer.MIN_VALUE;

3. Absolute value:
    (1) Java:
            int absDiff = Math.abs(4-5);

4. Comparison of two numerical values:
    (1) Java:
            int maxOfTwo = Math.max(5, 4);
            int minOfTwo = Math.min(5, 4);

5. Find the maximum/minimum in an array as well as the index:
    (1) Java:
        input: int[] height
        int highestPos = 0;
        int result = 0;
        for (int i = 0; i < height.length; ++i) {
            highestPos = (height[i] > height[highestPos]) ? i : highestPos;
        }

6. Convert String to Int:
    (1) Java:
            String number = "10";
            int result = Integer.parseInt(number);
            Integer result2 = Integer.valueOf(number);
7. Count the occurence of each character in a string:
    (1) Java:
            String t = "aerwerrsdf";
            Map<Character, Integer> TcharCounts = new HashMap<>();
            for (int i = 0; i < t.length(); ++i) {
                int curCount = TcharCounts.getOrDefault(t.charAt(i), 0);
                TcharCounts.put(t.charAt(i), curCount + 1);
            }
8. Substring:
    (1) Java (public String substring(int beginIndex,
               int endIndex) ), beginIndex is inclusive and endIndex is exclusive
            "hamburger".substring(4, 8) returns "urge"
            "smiles".substring(1, 5) returns "mile"

9. Find the index of a character in a string:
    (1) Java:
            String str1 = "allen chin is a hero";
            int pos1 = str1.indexOf('a'); // 0
            int pos2 = str1.indexOf('a', 3); // 14
        

10. Initialization of multiple variables:
    (1) Java supports this, which can also be used in for-loop
        int a1 = 3, a2 = 5, a3 = 7;

11. Switch syntax:
    (1) Java:
        public String getTypeOfDayWithSwitchStatement(String dayOfWeekArg) {
         String typeOfDay;
         switch (dayOfWeekArg) {
             case "Monday":
                 typeOfDay = "Start of work week";
                 break;
             case "Tuesday":
             case "Wednesday":
             case "Thursday":
                 typeOfDay = "Midweek";
                 break;
             case "Friday":
                 typeOfDay = "End of work week";
                 break;
             case "Saturday":
             case "Sunday":
                 typeOfDay = "Weekend";
                 break;
             default:
                 throw new IllegalArgumentException("Invalid day of the week: " +
                 dayOfWeekArg);
         }
         return typeOfDay;
        }

12. Conversion between primitive types and Binary Numeric Promotion


