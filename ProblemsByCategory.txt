Reference Books:
(1) Cracking the coding interview
(2) Head first Java
(3) Leetcode

1. Arrays and HashTables

Knowledge:
(1) Hash Tables -- implementation, performance, collision.
(2) Resizeable array
	Implementation: Vector(C++), ArrayList(Java)
	Performance: get, set is O(1), amortized time of add is O(1) and why. 
(3) Basic language syntax for array(fixed and dynamic), hash map and hash set.
(4) Implementation of equals and hashCode methods in Java(See <<Effective Java>>,
http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html)

Problems:
(1)[Leetcode]First Missing Positive(Algorithm and Implementation*)
(2) K Sum problems. Can be solved using two approaches:
    a. Sort the input array first. Then using two pointers starting from the beginning
    and the end of the array, moving one of them towards the other each time based on 
    the comparison of the sum of the two elements and target, until they meet. The two 
    pointers process takes O(n) time. No extra space needed.
    b. Using a hash set of list of n elements to record the results and remove duplicates.
    Sort the input array first if K > 2. Cache the sums and their corresponding elements
    while iterating the array. The result hash set has to be used to remove the duplicates!

    No matter which approach to use, divide K into two parts first. Iterate the second part
    and hash or iterate using two pointers on the first part.
    (2.1) Two sum
        (2.1.1) Input array is random, find out one solution.
            - [Leetcode] Two sum.
        (2.1.2) Input array is random, find out all unique solutions.
    (2.2) Three sum
        (2.1.1) Input array is random, find out all unique solutions.
            - [Leetcode] Three sum.
            - [Leetcode] Three sum closest.
    (2.3) Four sum(Random input array, find out all unique solutions)
        -[Leetcode] Four sum.
(3) Remove duplicates(Maximum allowed duplicates == K). Two ways of checking duplicates! 
    (3.1)[Leetcode] Remove Duplicates from Sorted Array(Best Algorithm*).
    (3.2)[Leetcode] Remove Duplicates from Sorted Array2(Best Algorithm*).
(4) Inward two pointers:
    (4.1)[Leetcode] Three sum problems.
    (4.2)[Leetcode] Container with most water(Algorithm)


2. Strings

Knowledge:
(1)JAVA: String, StringBuilder and char[]

Problems:
(1)[Leetcode]Integer To Roman(Algorithm*)
(2)[Leetcode]Roman To Integer(Algorithm*)
(3)Non-adjacent duplicates and sliding window:
    - [Leetcode]Longest Substring Without Repeating Characters(Best Algorithm* and Implementation), 
    - [Leetcode]Longest Substring with At Most K Distinct Characters(Algorithm* and Implementation*)


3. Linked Lists

Knowledge:
(1)Java: LinkedList class -- double linked list, performance
(2)Two pointers technique is frequently used! The diff between any two given linked list
can always be found in O(m+n) time.  
(3)Sometimes we can use the input pointers to reduce the number of pointers created.
(4)It is possible to delete a node only by using that pointer if that node is not the head
or tail --- by shifting the contents of the following nodes toward it and remove the last one.
(5)Adding dummy node to the front a linked list can be convenient for iterating over the list 
using two pointers, especially if we want to remove the first node, or insert in front of the 
first node. Think carefully about edge cases involving the head node if we want not to add the
dummy node.
(6)Edge cases: (think normal case first), insert/remove the first/last node, one node linked list,
null list.
(7)Three approaches for reversing linked list and their implementation(see below).

Problems:
(1)Node finding: 
	- [Leetcode]Intersection Of Two Linked Lists(Best Algorithm* and Best Implementation*)
	Remember this algorithm(including the first trial)!
(2)Remove nodes: 
	- [Leetcode]Remove Nth Node From End of List(Implementation, practice dummy node and edge case 
	thinking)
    - [Leetcode]Remove duplicates from sorted list I(easy) and II(Implementation*)
    - Generalization of above to allow K duplicates -- Remove duplicates from sorted list III.
    (Implementation* -- multiple cases)
(3)Reverse nodes: 
	(3.1). Basic head insertion(Iterative and recursive) -- creating a new linked list, original head 
	pointer will become tail pointer, and the new head pointer keeps updating. No need for the dummy node.
	   - [Leetcode] Reverse Linked List(Implementation, recursive algorithm*)
	(3.2). Incremental head insertion -- This process includes node removing and node insertion.
	   Must add dummy node. Must start from the second node(cur node start from curTail.next) and use 
	   a pointer pointing to the tail node(curTail is fixed!) that other nodes are inserted before. 
	   - [Leetcode]Swap Nodes in Pairs(Implementation)
	   - [Leetcode]Reverse Nodes in K-Group(Algorithm* and Implementation*)
	   - [Leetcode]Reverse Linked List II(Implementation*)
	(3.3). Tail insertion. Inserting each node right after the original tail node. Need to first aquire
	 pointer to the tail node and then start from the first node. Original tail node will become new
	 head node. Pointer to the original head node need to be stored or it will be lost.
	   - [Leetcode]Reverse Nodes in K-Group(Algorithm* and Implementation*)
(4)Copy linked list:
	- [Leetcode]Copy List with Random Pointer(Algorithm*, two approaches)


Implementation Utils:
1. Sorting an array:
    (1) Java:
            int[] nums;
            Arrays.sort(nums);//In place, stable, O(nlogn) time.
2. Max and min Int
    (1) Java:
            Integer.MAX_VALUE;
            Integer.MIN_VALUE;
3. Absolute value:
    (1) Java:
            int absDiff = Math.abs(4-5);
5. Comparison of two numerical values:
    (1) Java:
            int maxOfTwo = Math.max(5, 4);
            int minOfTwo = Math.min(5, 4);

4. Convert String to Int:
    (1) Java:
            String number = "10";
            int result = Integer.parseInt(number);
            Integer result2 = Integer.valueOf(number);

