Reference Books:
(1) Cracking the coding interview
(2) Head first Java
(3) Leetcode

1. Arrays and HashTables

Knowledge:
(1) Hash Tables -- implementation, performance, collision.
(2) Resizeable array
	Implementation: Vector(C++), ArrayList(Java)
	Performance: get, set is O(1), amortized time of add is O(1) and why. 
(3) Basic language syntax for array(fixed and dynamic), hash map and hash set.

Problems:
(1)[Leetcode]Two Sum.
(2)[Leetcode]First Missing Positive(Algorithm and Implementation*)

2. Strings

Knowledge:
(1)JAVA: String, StringBuilder and char[]

Problems:
(1)[Leetcode]Integer To Roman(Algorithm*)
(2)[Leetcode]Roman To Integer(Algorithm*)

3. Linked Lists

Knowledge:
(1)Java: LinkedList class -- double linked list, performance
(2)Two pointers technique is frequently used! The diff between any two given linked list
can always be found in O(m+n) time.  
(3)Sometimes we can use the input pointers to reduce the number of pointers created.
(4)It is possible to delete a node only by using that pointer if that node is not the head
or tail --- by shifting the contents of the following nodes toward it and remove the last one.
(5)Adding dummy node to the front a linked list can be convenient for iterating over the list 
using two pointers, especially if we want to remove the first node, or insert in front of the 
first node.
(6)Edge cases: (think normal case first), insert/remove the first/last node, one node linked list,
null list.
(7)Three approaches for reversing linked list and their implementation(see below).

Problems:
(1)Node finding: 
	- [Leetcode]Intersection Of Two Linked Lists(Best Algorithm* and Best Implementation*)
	Remember this algorithm(including the first trial)!
(2)Remove nodes: 
	- [Leetcode]Remove Nth Node From End of List(Implementation, practice dummy node and edge case 
	thinking)
(3)Reverse nodes: 
	a. Basic head insertion(Iterative and recursive) -- creating a new linked list, original head 
	pointer will become tail pointer, and the new head pointer keeps updating. No need for the dummy node.
	   - [Leetcode] Reverse Linked List(Implementation, recursive algorithm*)
	b. Incremental head insertion -- This process includes node removing and node insertion.
	   Must add dummy node. Must start from the second node(cur node start from curTail.next) and use 
	   a pointer pointing to the tail node(curTail is fixed!) that other nodes are inserted before. 
	   - [Leetcode]Swap Nodes in Pairs(Implementation)
	   - [Leetcode]Reverse Nodes in K-Group(Algorithm* and Implementation*)
	   - [Leetcode]Reverse Linked List II(Implementation*)
	c. Tail insertion. Inserting each node right after the original tail node. Need to first aquire
	 pointer to the tail node and then start from the first node. Original tail node will become new
	 head node. Pointer to the original head node need to be stored or it will be lost.
	   - [Leetcode]Reverse Nodes in K-Group(Algorithm* and Implementation*)
(4)Copy linked list:
	- [Leetcode]Copy List with Random Pointer(Algorithm*, two approaches)

